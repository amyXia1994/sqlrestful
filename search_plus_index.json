{"./":{"url":"./","title":"0、SQLRestful概要说明","keywords":"","body":"SQLRestful概要说明 云原生开发工具 SQLRestful是一个开箱即用的云原生微服务开发工具，通过SQLRestful您可以快速变现数据库设计为Restful微服务接口。它采用Go语言实现，开发者通过HCL配置语言实现微服务接口开发，其配置语法直遵循Restful规范及面向对象微服务的设计思路，其目的是为了尽量缩短服务组件从设计到部署的实现周期。 基于SQLRestful您可以借助传统的SQL与JavaScript技术来快速响应需求，解决云原生开发环境下的人员技能无法跟上发展的窘况。 什么是云原生应用 2015年谷歌成立了原生云计算基金会（CNCF），目前基金会成员包含Box、华为、思科、Docker、eBay、IBM、英特尔、红帽、Twitter、VMware、三星等70多家成员。 CNCF认为CloudNative（云原生）系统需包含的属性： 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用，简化云原生应用程序的维护。在容器中运行应用程序和进程，并作为应用程序部署的独立单元，实现高水平资源隔离。 自动化管理：统一调度和管理中心，从根本上提高系统和资源利用率，同时降低运维成本。 面向微服务：通过松耦合方式，提升应用程序的整体敏捷性和可维护性。 而云原生应用开发方式主要解决传统开发面临的问题： 设计、开发、测试、部署、运维无法一体化，迭代困难； 无法做到随需扩展部署导致并发能力固化，资源利用率低； 为我们提供捐助 如果您觉得SQLRestful云原生开发工具能给您带来收益： 设计思路上的借鉴； 节省了您的项目成本； 让您的SQL技能继续发光发热； 给您带来了更多闲暇时间； (留给您来补充！) 在您心情愉悦之际，扫下方的二维码捐助我们： 微信扫码 支付宝扫码 感谢您的打赏支持！ 开源仓库地址 https://github.com/neeker/sqlrestful 2019-2010 © 版权所有 "},"origin.html":{"url":"origin.html","title":"1、SQLRestful设计初衷","keywords":"","body":"SQLRestful设计初衷 一直在使用Java+SpringBoot作为微服务生产力工具，通常来讲实现一个Restful微服务接口需要做以下相关工作： ORM映射实现：通常使用MyBatis，需要写Pojo类、Mapper类和SQLProvider类。 服务层实现：需要一个对象管理接口类与一个对象管理实现类。 控制层实现：一个RestConfoller类并注解Rest方法再调用服务层实现。 Devops配置：Dockerfile、k8s部署描述文件等等。 这样一个Restful接口实现下来至少需要5个以上的类，大部分工作是在做转换、校验等语言相关的工作。 我们可以想想从SQL到Restful经历了多少层的实现，而大部分工作是毫无意义的规则代码。。。 您可能会建议我使用spring-cloud开发框架，但一样也少不上述过程。 因此一直以来，我一直想要有一个工具可以直接把SQL转成Restful微服务接口，同时它必须是云原生的开发方式： 1、配置化实现：通过简单的配置边可以很方便的实现SQL转Restful接口； 2、执行效率高：不能因为配置和转换减低运行效率； 3、可容器化部署：能方便打包成Docker镜像并运行； 4、多数据库支持：包括oracle、db2、mysql、postgres、hadoop等。 通过此工具可以快速对外提供Restful规范的数据微服务接口，满足碎片化的数据服务需求应用场景的快速响应。 说干就干，于是我找到了sqler，但是sqler仅支持REST而不支持完整的Restful规范。 因此我在其基础之上实现了一个完整的SQL转Restful接口的服务工具，兼容sqler配置语法的同时进行了Restful配置扩展实现。 感谢开源！ 2019-2010 © 版权所有 "},"start.html":{"url":"start.html","title":"2、SQLRestful入门示例","keywords":"","body":"SQLRestful开发入门示例 开发环境要求 docker notepad或vscode或editplus curl（可选） Linux或Windows 准备SQLRestful脚本 使用如下命令创建一个demo.hcl文件： cat>demo.hcl 👉这里可以直接下载demo.hcl文件👈。 运行SQLRestful开发的微服务 命令行执行以下docker命令运行示例脚本开发的微服务接口： docker run -ti --rm -p 80:80 \\ -v /path/of/your_demo.hcl:/test/demo.hcl:ro \\ snz1/sqlrestful \\ -driver \"sqlite3\" \\ -dsn \"/test/db.sqlite?create=true\" \\ --swagger \\ -debug 3 \\ -config /test/demo.hcl \\ -p 80:80前面那个80表示宿主机转发的端口 /path/of/your_demo.hcl为你创建的SQLRestful脚本文件 测试微服务接口 如果你使用远程主机运行SQLRestufl服务请把下面命令中的127.0.0.1替换成远程主机地址。 新增数据测试 命令行执行： curl -X POST \"http://127.0.0.1/test?name=hello&hello=world\" 命令行返回： {\"code\":0,\"data\":{\"hello\":\"world\",\"name\":\"hello\"},\"message\":\"操作成功！\"} 查询数据测试 命令行执行： curl -X GET \"http://127.0.0.1/test?limit=15 命令行返回： {\"code\":0,\"data\":{\"data\":[{\"hello\":\"world\",\"name\":\"hello\"}],\"offset\":\"0\",\"total\":1},\"message\":\"操作成功！\"} 通过swagger测试 新开标签并打开网址http://127.0.0.1/doc.html，如下图所示： SQlRestful提供了一个SwaggerUI界面用于测试实现的微服务接口，其默认是禁用的。如果需要启用SwaggerUI界面请在启动命令中加上-swagger开关。 进一步了解 SQLRestful除了可以使用sql实现简单的微服务接口外，还可以配合js脚本实现复杂功能的，包括： 内置多种数据库支持（参见【数据库支持列表】） 可通过js脚本实现可变条件的SQL查询； 可通过js配置实现对请求参数的校验； 可通过js实现SQL查询结果转换； js脚本可请求其他接口并支持jwt规范； 为接口提供配置方式的Redis缓存实现； 提供基于用户统一安全认证服务规范的权限验证配置 使用建议 ☞ SQLRestful云原生开发工具是为了节省数据中台服务接口的开发成本！ ☞ SQLRestful不能适用于复杂业务逻辑的应用场景，总之合适的才是最好的！ 2019-2010 © 版权所有 "},"hcl.html":{"url":"hcl.html","title":"3、HCL配置语言入门","keywords":"","body":"HCL配置语言入门 HCL配置语言请参见HCL官网。 它是大名鼎鼎的云基础架构自动化工具hashicorp实现的配置语言， 它吸收了JSON与YAML及一些脚本语言的特性，自身兼容JSON语法： 单行注释以#或开头// 多行注释包含在/和中/。不允许嵌套块注释。多行注释（也称为块注释）在第一个*/找到时终止。 属性值设置用key = value（空格忽略）表示。value可以是字符串，数字，布尔值，对象或列表。 字符串必须用双引号，可以包含任何UTF-8字符。例：\"Hello, World\" 多行字符串从一行 数字默认为10禁止，如果前缀为0x的数字，则将其视为十六进制。如果它以0为前缀，则将其视为八进制。数字可以是科学记数法：“1e10”。 布尔值：true，false 数组可以通过包装来制作[]。示例： [\"foo\", \"bar\", 42]。数组可以包含基础类型、其他数组和对象。作为替代方案，可以使用以下结构使用重复的块创建对象列表： service { key = \"value\" } service { key = \"value\" } 2019-2010 © 版权所有 "},"macros.html":{"url":"macros.html","title":"4、SQLRestful语法结构","keywords":"","body":"SQLRestful的HCL语法结构 SQLRestful采用HCL语言配合SQL、JavaScript脚本来开发微服务接口。 参见上一章HCL配置语言入门了解HCL语言基本概念 SQLRestful设计上遵循Restful规范，采用路径、方法对应对象的不同操作语义，具体结构如下图所示： 2019-2010 © 版权所有 "},"macro.html":{"url":"macro.html","title":"4.1、基本语法结构","keywords":"","body":"基本语法结构 SQLRestful由服务配置、接口定义两部分构成，其中服务配置包括名称、概述、版本、作者、数据库连接、缓存连接等，接口定义又分为两层结构：路径定义与方法定义。 服务配置 //描述信息 _meta { //名称 name = \"SQLRestful\" //版本 version = \"1.0\" //描述 desc = \"SQLRestful，您的云原生应用生产力工具！\" //作者 author { //姓名 name = \"痞子飞猪\" //邮箱 email = \"13317312768@qq.com\" } //数据库配置 db { //数据库驱动名 driver = \"sqlite3\" //数据库连接 dsn = \"sqlte3.db?create=true\" //Redis缓存连接 redis = \"redis://:password@:6379/0\" } //安全配置 security { //统一用户安全服务地址 api = \"https://snz1.cn/test/xeai\" //用户标识头 from = \"iv-user\" //用户标识类型 idtype = \"uname\" //组织域范围 scope = \"employee\" } //应用身份配置：JWT请求令牌 jwt = { //应用私钥(PEM格式) rsa = 服务配置项说明 name 服务名称定义 version 服务实现版本 desc 服务实现描述 author 服务维护人员，包括名称（name）、邮件（email）、网址（url）属性。 db 服务数据库连接配置，包括驱动（driver）、连接（dsn）、Redis缓存（redis）属性。 security 统一安全服务接口配置，包括服务接口地址（api）、用户标识请求头（from）、用户标识类型（idtype）、组织域范围（scope）属性。 jwt 应用身份配置，包括RSA私钥（rsa）、协商密钥（secret）、令牌超时时间（expires）等属性。 const 全局常量配置表，键值为js表达式。 mq 消息服务配置，包括消息插件名称（driver）、消息连接地址（url）等属性。 接口定义 路径定义语法 //接口名称，不能包含“\\”、“/”、“:”等特殊字符 api { //接口地址，省略时使用接口定义名称作为接口地址，可使用“:变量”方式定义路径变量 path = \"/path/of/object_items\" //服务接口的分类标签（可忽略） tags = [\"标签\"] //摘要描述（可忽略） desc = \"\" //常量定义 const { ... } //接口GET请求方法 get { ... //方法定义 } //POST请求方法 post { ... //方法定义 } //PUT请求方法 put { ... //方法定义 } //PATCH请求方法 patch { ... //方法定义 } //DELETE请求方法 delete { ... //方法定义 } } 当路径定义只有一种方法实现可以直接使用方法定义语法来简化接口定义： api_name { path = \"/path/of/api\" //可省略，默认为`GET` methods = [ \"GET\" ] //参见【方法定义语法】 } 方法定义语法 // method只能为：get、post、put、patch、delete method { //服务接口的分类标签（用于swagger文档输出，可忽略），可继承自上级定义 tags = [\"标签\"] //摘要描述（用于swagger文档输出，可忽略） desc = \"\" //预先执行其他接口：接口列表 include = [\"_boot\"] //校验表达式：JS脚本实现 validators { value = \"express value\" //表达式为真表示校验通过 } //身份验证：返回true表示身份验证通过（可忽略） authorizer = scope = \"employee\" //判定角色列表 roles = [ \"ADMIN\" ] //判定用户列表 users = [ \"neeker\" ] //角色或用户判定策略： // 为allow时表示请求用户必须包含roles中定义的角色、用户必须在users定义的列表中 // 为deny时表示请求用户不能是roles定义的角色、用户不能再users定义的列表中 //条件不满足则返回403应答 policy = \"allow\" } //Redis缓存配置（无redis连接配置时无效） cache { //缓存名称列表(HSET)：使用input作为field主键 put = [\"cache_name\"] //移除缓存(HSET)：删除HSET主键 evit = [\"cache_name\"] } //表示total与exec的脚本类型：sql（默认），js（JavaScript），cmd（命令） impl = \"sql\" //SQL执行变量绑定，impl = \"sql\"时生效 bind { sql_param1 = \"$input.id\" //JS脚本 sql_offset = \"$input.offset\" //默认为0 sql_limit = \"$input.limit\" //默认为0 } //提供待执行的脚本（JS）：存在则忽略total、exec的定义 provider = 接口定义项说明 接口名称 以英语字母开头的英文名称，后面可以是字母、数字或_，不能包含:、/、\\、-等特殊字符。 path 表示接口路径，可以使用:开头作为路径变量，每个路径变量只能匹配一层路径，如： /users/:id/name tags 文档归类标签列表，可以把多个不同的接口规定到同一个文档标签下展示，仅用于SwaggerUI。 desc 接口实现概述，仅用于SwaggerUI。 const 常量列表定义，此处定义的常量在js脚本可通过$const.xxx方式获取到。常量值可以是js表达式或js脚本。 get 仅在路径定义中有效，表示定义指定路径的GET方法实现。 post 仅在路径定义中有效，表示定义指定路径的POST方法实现。 put 仅在路径定义中有效，表示定义指定路径的PUT方法实现。 patch 仅在路径定义中有效，表示定义指定路径的PATCH方法实现。 delete 仅在路径定义中有效，表示定义指定路径的DELETE方法实现。 include 执行其他接口实现。 validators 验证表达式，每个定义的验证配置项必须返回true，否则返回422应答。 authorizer 使用js实现身份验证。 security 统一用户安全配置，包括可否匿名访问（anonymous）、定义组织域（scope）、定义角色列表（roles）、定义用户列表（users）、判定策略（policy）等配置。 policy为allow时表示允许定义的角色或用户访问； policy为deny时表示不允许定义的角色或用户访问； cache 接口缓存配置，包括设置缓存列表（put）或清理缓存列表（evit）。 impl 表示接口的exec与total实现脚本类型： 为sql时表示SQL查询语句（默认） 为js时表示JavaScript脚本 为cmd时表示命令行及参数 bind impl为sql时表示exec中的SQL查询命名绑定参数。 bind也为SwaggerUI提供输入参数的定义描述。 total 存在时表示接口为分页接口，并返回查询记录总数。 exec 服务接口实现脚本 transformer 用于转换exec执行返回的数据，采用js脚本实现。 result 定义数据类型，object表示对象、list表示列表、page表示分页（total存在时强制为page）。 format 定义应答格式，enclosed表示信封封装、origin表示原样返回、nil表示只返回封装头。 aggregate 组合其他接口定义执行返回。 websocket 定义接口是否为websocket服务，当启用了websocket服务时，接口定义的脚本在客户端消息到达时被执行。 dir 定义静态文件目录路由，存在时忽略其他配置，只返回目标文件夹中的静态文件。 file 定义静态文件路由，存在时忽略其他配置，只返回目标静态文件。 2019-2010 © 版权所有 "},"ret.html":{"url":"ret.html","title":"4.2、接口返回数据格式","keywords":"","body":"接口返回数据格式 默认格式 默认情况下SQLRestful定义的微服务接口采用信奉封装的JSON数据格式返回，数据格式如下所示： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 \"data\": { //`exec`返回的数据内容 ... } } 返回单数据对象 如果定义的exec脚本由SQL语言实现（默认情况），此时exec执行默认返回的是行数据，如果需要返回单个数据对象时在接口定义加上以下配置属性： result = `object` 分页数据格式 接口定义时加了total配置属性，则表示接口返回分页数据格式，如下所示： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 \"data\": { // 分页数据对象 \"offset\": 0, // 起始索引 \"total\": 0, // 总记录数，由total脚本返回的数值 \"data\": [...] //分页数据列表，exec执行返回的列表 } } 原样返回数据 如果需要原样返回脚本的数据则需要在接口定义加上以下配置： format = \"origin\" 不返回任何数据 如果需要接口不返回任何数据时，你可以在接口配置上添加'format = \"nil\"'，此时接口仅返回封装头： { \"code\": 0, //响应代码：非0时表示不成功 \"message\": \"操作成功\", //响应消息：非0时表示错误消息 } 2019-2010 © 版权所有 "},"sql.html":{"url":"sql.html","title":"4.3、SQL参数绑定","keywords":"","body":"SQL参数绑定 SQLRestful默认采用SQL来实现Restful接口（参见total与exec定义项）。 我们通过bind来配置SQL动态命名参数。其中的属性定义值是JavaScript表达式（也可以是JavaScript闭包函数），参见如下示例配置： bind { name_arg = \"'%' + $input.name + '%'\" end_arg = $input表示接口请求参数对象集，具体请参见《使用JavaScript脚本》章节。 通过上述配置后，可以在exec或total的SQL代码中使用“:”的绑定参数，如下所示： exec = 2019-2010 © 版权所有 "},"mul.html":{"url":"mul.html","title":"4.4、执行多段SQL","keywords":"","body":"执行多段SQL 在某些情况下一个exec实现可能需要分为多个SQL段执行，在脚本加入“---”分隔符，如下代码所示： exec = 注意： exec与total始终以最后一段SQL的返回作为返回数据。 2019-2010 © 版权所有 "},"js.html":{"url":"js.html","title":"4.5、使用JavaScript脚本","keywords":"","body":"使用JavaScript脚本 javascript脚本定位 SQLRestful定位就是采用SQL与JavaScript完成微服务开发，其中JavaScript脚本用于完成下述工作： 与其他微服务接口进行交互； 实现请求身份验证功能； 校验请求参数是否合法； 请求参数到SQL绑定参数转换； SQL返回结果的转换能力； 实现微服务逻辑处理功能； 它支持完整的ECMAScript 5.1规范（由 goja 提供实现支持）。 javascript脚本默认变量 在SQLRestful中，参数转换（bind宏），身份验证实现（authorizer宏）的JS脚本可以通过$input变量 获取到请求输入参数列表，同时可以通过$input.http_xxxx来获取请求头内容，假设客户端请求发送一个名称为X-Test-MM 的请求，则通过以下表达式拿到请求头内容： $input.http_x_test_mm 所有请求头都会转换成小写加上http_前缀，同时为了遵循JS对象属性命名规则会把“-”替换为“_”。 应答转换（transformer宏）的脚本通过变量$result可以获取到exec宏返回的原始数据，具体见如下示例代码： test { ... transformer = 除此之外，每个JS脚本都可以获取以下参数： 参数名 参数说明 $input.http_method 当前请求方法：GET、POST、PUT、PATCH、DELETE $input.http_scheme 当前请求协议头：http、https $input.http_path 当前请求上下文路径 $input.http_url 当前请求URL地址 $input.http_uri 当前请求URI地址 $input.http_remote_addr 当前请求远程IP地址（或前置代理地址） $input.http_real_ip 当前请求真实IP地址：请求头X-Forwarded-For或X-Real-IP的值 $input.data 消息对象，接口定义为监听消息队列或者websocket接口时 $input.__clientid__ 客户端ID，接口为websocket时 $name 当前微服务实现宏名称 $stage 宏JS所在过程名称：validators、authorizer、const、transformer、bind、provider、exec、total javascript脚本内置函数 SQLRestful为JS脚本内置了两个默认的HTTP请求函数和一个控制台日志输出函数： fetch call_api log exec_sql exec_cmd emit_msg ws_broacast ws_send call_macro fetch函数 函数原型 function fetch(URL, { method: \"HTTP METHOD\", //请求方法，如GET、POST、PUT headers: { //请求头 ... }, body: ... //请求体，可以是JSON或字符串。 }) 返回结果 { \"status\": \"应答状态文本\", \"statusCode\": \"HTTP应答码\", \"headers\": \"HTTP应答头\", \"body\": \"应答内容字符串\", } call_api函数 此函数提供后台调用在应用网关中注册的微服务后台接口。 它通过SQLRestful服务配置的 JWT RSA 私钥与 JWT 安全令牌产生 JWT 请求令牌并发起接口请求。 具体JWT令牌请求方式参见《通过网关调用后台服务接口 》中的说明。 函数原型 function call_api(URL, { method: \"HTTP METHOD\", //请求方法，如GET、POST、PUT headers: { //请求头 ... }, body: ... //请求体，可以是JSON或参数内容。 }) 返回结果 正常情况下 call_api 函数直接返回接口的JSON对象，只有在请求出错的情况下返回如下定义： { \"status\": \"应答状态文本\", \"statusCode\": \"HTTP应答码\", \"headers\": \"HTTP应答头\", \"body\": \"应答内容字符串\", } 如果请求的接口应答内容不能转换为JSON对象则返回与fetch函数相同的应答： log函数 函数原型 function log(message, ...) 使用示例 (function(){ log(\"debug:\", \"hello world!\") })() exec_sql函数 执行SQL查询语句并返回查询结果。 函数原型 function exec_sql(cmdline, args{}) 使用示例 (function(){ var ret = exec_sql(\"select * from where id = :id\", { id: 10000 }) return ret === undefined ? undefined : ret[0] })() exec_cmd函数 用于执行命令并返回结果。 函数原型 function exec_cmd(command, args...) 使用示例 (function(){ var dirout = exec_cmd(\"ls\", \"-l\", \"/\") })() emit_msg函数 用于发送消息并返回结果。 函数原型 emit_msg(dest, msg, headers{...}) 使用示例 (function(){ var dirout = emit_msg(\"app.foo.bar\", \"test message queue\") })() ws_broacast函数 用于广播websocket消息。 函数原型 ws_broacast(endpoint, msg{...}) 使用示例 (function(){ ws_broacast(\"test\", \"test msg\") })() ws_send函数 用于发送websocket消息到指定的客户端。 函数原型 ws_send(endpoint, clientid, msg{...}) 使用示例 (function(){ ws_send(\"test\", $input.__clientid__, \"test msg\") })() call_macro函数 用于请求其他的定义实现。 函数原型 exec_macro(macro, input{...}) 使用示例 (function(){ exec_macro(\"input\", {test:\"test msg\"}) })() 2019-2010 © 版权所有 "},"professor.html":{"url":"professor.html","title":"5、SQLRestful进阶指南","keywords":"","body":"SQLRestful进阶指南 通过SQLRestful语法我们可以快速实现更复杂的实现，包括以下特性： 实现SQL条件分支：根据请求参数完成不同的分支实现。 使用JavaScript脚本实现：直接集成已有微服务接口的应用场景。 使用JWT请求令牌请求其他接口：集成通过服务网关提供的微服务接口。 使用统一用户安全认证服务：集成统一用户安全认证服务实现权限管理。 使用消息队列：在服务定义中实现消息接收与消息发送。 反向代理其他接口服务，利于本地开发测试集成。 2019-2010 © 版权所有 "},"sqlx.html":{"url":"sqlx.html","title":"5.1 根据请求参数实现条件分支","keywords":"","body":"根据请求参数实现条件分支 应用场景 有时我们需要根据不同的请求参数来组装SQL的不同条件语句，例如当请求参数传入了年龄参数就需要获取符合年龄条件的 人员，如果请求未传入年龄参数则不需要根据年龄过滤数据，此类场景在一条SQL查询语句中显然无法实现。 此时便需要我们使用执行提供器配置方式（provider配置）来完成复杂的SQL条件分支实现。 provider provider配置采用JavaScript实现，定义了provider意味着微服务接口接下来的执行脚本（包括total与exec)由provider定义的JavaScript返回。 只返回exec执行脚本 provider返回格式可以是简单的字符串，返回的字符串直接用于exec执行，如下所示： provider = 同时返回total与exec provider可以返回用于分页查询接口的total与exec脚本，如下所示： provider = 同时返回脚本类型 provider = total可以不存在于返回结果中，存在则表示实现分页查询接口 impl可以是js（表示JavaScript脚本）、cmd（表示SHELL脚本命令）。 2019-2010 © 版权所有 "},"jsx.html":{"url":"jsx.html","title":"5.2 使用JavaScript实现接口","keywords":"","body":"使用JavaScript实现接口 应用场景 默认情况下SQLRestful接口使用SQL来实现，但某些场景下我们不需要使用SQL而是需要调用其他Restful微服务接口： 多个Restful微服务接口的数据组合； 需要对已有的Restful数据做脱敏等实现； 第三方公有云服务接口的封装等； 配置方法 在接口定义上使用impl = \"js\"配置后可直接对exec或total实现采用JavaScript，如下所示： impl = \"js\" total = 此处的JavaScript可以使用《使用JavaScript脚本》章节中说明的内置函数。 2019-2010 © 版权所有 "},"cmd.html":{"url":"cmd.html","title":"5.3 使用外部SHELL命令实现接口","keywords":"","body":"使用外部SHELL命令实现接口 应用场景 某些情况下可能需要使用已有SHELL脚本或已实现的命令行程序来快速对外提供Restful微服务接口： 想要快速把命令行操作转成Restful微服务接口（自动化运维应用） 配置方法 在接口定义上使用impl = \"cmd\"配置后可直接对exec实现调用SHELL命令，如下所示： path = \"/docker_pull\" bind { pull = \"$input.img\" } impl = \"cmd\" exec = \"docker\" 参数绑定规则： 在bind中配置的SHELL命令输入参数会以如下方式传入到exec配置的命令中： docker pull 命令执行展开规则： ... 命令执行返回 客户端请求命令实现的微服务接口时阻塞直至命令执行完成，SQLRestful获取SHELL命令的控制台输出字符串返回。 返回数据格式参见《Restful接口返回的数据格式》章节。 2019-2010 © 版权所有 "},"jwt.html":{"url":"jwt.html","title":"5.4 使用JWT身份令牌请求其他接口","keywords":"","body":"使用JWT身份令牌请求其他接口 应用场景 如果您的SQLRestful实现需要通过应用网关调用其他微服务接口时，必然需要使用JWT规范的 身份令牌来完成调用。 准备JWT应用身份资料 通过应用网关调用其他微服务接口约定，生成JWT请求令牌必须遵循JWT RS256算法约定，需要准备证明应用身份的资料： RSA私钥：对应公钥在已在网关端登记注册 JWT安全令牌：协商密钥，由网关随机生成 以JWT应用身份运行容器 准备JWT应用身份资料后，我们需要把RSA私钥文件加载到镜像的文件系统中，然后在运行命令行中加入jwt-keyfile、jwt-secret、jwt-expires参数，如下示例命令： docker run -ti --rm \\ -v /path/of/app.pem:/sqlrestful/app.pem:ro \\ snz1/sqlrestful \\ -jwt-keyfile \"/sqlrestful/app.pem\" \\ -jwt-secret \"***********\" \\ -jwt-expires=3600 \\ ... 在文件中配置JWT应用身份 _meta { //... jwt { //RSA私钥（PEM格式） rsa = 使用JWT请求令牌调用其他接口 通过上述配置后在JavaScript脚本中我们便可以使用内置的call_api函数携带令牌请求其他微服务接口： (function(){ var ratdata = call_api(\"http://appgateway.domain/paht/of/api\", { method: \"GET\", headers: { ... }, body: { ... } }) })() 内置的call_api函数根据JWT应用身份资料自动生成JWT请求令牌请求指定的接口。 直接获取JWT请求令牌 (function(){ var jwt_token = jwt_token() })() 2019-2010 © 版权所有 "},"xeai.html":{"url":"xeai.html","title":"5.5 使用用户统一安全认证服务","keywords":"","body":"使用用户统一安全认证服务 应用场景 如果我们的接口面向用户前端，此时必然涉及用户身份验证及权限验证问题，虽然通过authorizer配置项可以使用JavaScript脚本来实现用户身份验证及权限验证，但总的来说实现还是稍显繁琐了。 此时我们可以通过security配置项来对接口定义用户及权限角色访问控制。 注：security配置项需要用户统一安全认证服务组件支持。 配置方法 security可以针对接口配置以下验证方式： 可以访问接口的登录用户或角色 不能访问接口的登录用户或角色 security { //是否允许匿名访问，为true时不判定用户身份 anonymous = false //用户所属组织域：参见 scope = \"employee\" //判定角色列表 roles = [ \"ADMIN\" ] //判定用户列表 users = [ \"neeker\" ] //角色或用户判定策略： // 为include时表示请求用户必须包含roles中定义的角色、用户必须在users定义的列表中 // 为exclude时表示请求用户不能是roles定义的角色、用户不能再users定义的列表中 //条件不满足则返回403应答 policy = \"allow\" } 运行配置 开启security配置功能需要在启动命令行中加入uumapi、useridtype、userscope参数： uumapi表示用户统一安全认证服务地址 useridtype表示通过请求头获取到的用户身份标识类型（包括：id、uname等） userscope表示登录用户所在的组织域代码（登录的用户必须在该组织域下才能访问） 2019-2010 © 版权所有 "},"mq.html":{"url":"mq.html","title":"5.6 监听消息队列与发送消息","keywords":"","body":"监听消息队列与发送消息 应用场景 有时可能需要接收来自消息消息队列中的消息入库或执行某个操作（如：流式数据计算时），或者把Restful请求转入消息队列时就需要使用消息处理机制。 在SQLRestful中我们也是使用配置式的方式使用消息队列能力。 使用消息队列 监听消息 //服务配置 _meta { //消息驱动配置 mq { //消息驱动 driver = \"stomp\" //连接地址 url = \"tcp://stomp_host:port/\" } } _msg_handler { //监听队列 consume { //消息队列名称（或主题名） name = \"queue_name\" //ACK标记：auto（默认）、client、each ack = \"auto\" //... } //SQL参数绑定：$input表示来自消息队列中的参数，如$input.xxx bind { // ... } //执行代码 exec = 发送消息 (function(){ emit_msg(\"queue_name\", \"msg object\", { //消息头 }) })() 2019-2010 © 版权所有 "},"websocket.html":{"url":"websocket.html","title":"5.7 实现websocket服务接口","keywords":"","body":"实现websocket服务接口 应用场景 当我们需要与客户端建立长连接通道时需要使用websocket。 SQLRestful中定义的websocket服务接口采用客户端消息驱动机制实现： 每次任何一个客户端消息到达时都会执行接口定义的exec脚本，其会把最终执行结果作为一个JSON消息对象发送给消息发送客户端（定义format等于nil时则不返回消息） 实现websocket接口 语法结构 test { websocket { enabled = true } impl = \"js\" exec = 在exec中可以通过以下变量获取请求信息： $input.__clientid__： 获取当前发送消息的客户端ID $input.data：获取到客户端发送的消息对象 可用的js函数 ws_broacast ws_broacast('', { ... }) ws_send ws_send('接口名称，如：test', '客户端ID', { ... }) 其他说明 通过消息队列与数据库配合即可复杂的websocket应用。 2019-2010 © 版权所有 "},"custom.html":{"url":"custom.html","title":"5.8 以容器(docker)方式部署服务","keywords":"","body":"如何实现自定义镜像 既然是云原生开发方式，最终我们编写的微服务接口需要以容器的方式打包部署。 准备Dockerfile文件 根据实际情况准备Dockerfile，添加开发好的SQLRestful文件（hcl）到打包镜像中，具体如下所示： # 引入sqlrestful镜像 FROM snz1/sqlrestful # 把你的HCL配置文件添加到镜像的`/sqlrestful`目录下 ADD /sqlrestful/ # 根据生产环境，自定义入口配置参数 ENTRYPOINT [\"sqlrestful\", \"--config\", \"/sqlrestful/*.hcl\"] 编译你的Docker镜像 docker build -t your_docker_img . 临时运行你的Docker镜像 docker run -ti --rm your_docker_img 2019-2010 © 版权所有 "},"db.html":{"url":"db.html","title":"6、数据库支持列表","keywords":"","body":"数据库支持列表 SQLRestful使用Go的https://github.com/jmoiron/sqlx第三方库实现SQL封装，sqlx基于database/sql，因此大部分有database/sql驱动实现的数据库都可以纳入SQLRestful实现支持。 驱动名 数据库 DSN mysql MySQL usrname:password@tcp(server:port)/dbname?option1=value1&... postgres PostgresQL postgresql://username:password@server:port/dbname?option1=value1 user= password=dbname= sslmode=disable connect_timeout=3 host= sqlite3 SQLite3 /path/to/db.sqlite?option1=value1 mssql SQLServer server=localhost\\\\SQLExpress;user id=sa;database=master;app name=MyAppName server=localhost;user id=sa;database=master;app name=MyAppName odbc:server=localhost\\\\SQLExpress;user id=sa;database=master;app name=MyAppName odbc:server=localhost;user id=sa;database=master;app name=MyAppName hdb SAP HANA hdb://user:password@host:port clickhouse Yandex ClickHouse tcp://host1:9000?username=user&password=qwerty&database=clicks&read_timeout=10&write_timeout=20&alt_hosts=host2:9000,host3:9000 oci8 Oracle username/password@host:port/sid 目前oci8驱动基于Oracle Instant Client 12.2.0.1.0编译，因此需要oci-12.2.0.1.0动态库支持。 2019-2010 © 版权所有 "},"mqm.html":{"url":"mqm.html","title":"7、消息协议支持列表","keywords":"","body":"消息协议支持列表 SQLRestful使用插件方式支持消息队列，目前支持stomp（已测试）、amqp（已测试）。 2019-2010 © 版权所有 "}}